// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TELEMSTDCAM_MAGAOX_LOGGER_H_
#define FLATBUFFERS_GENERATED_TELEMSTDCAM_MAGAOX_LOGGER_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace MagAOX {
namespace logger {

struct ROI;
struct ROIBuilder;

struct TempCtrl;
struct TempCtrlBuilder;

struct Shutter;
struct ShutterBuilder;

struct Telem_stdcam_fb;
struct Telem_stdcam_fbBuilder;

inline const ::flatbuffers::TypeTable *ROITypeTable();

inline const ::flatbuffers::TypeTable *TempCtrlTypeTable();

inline const ::flatbuffers::TypeTable *ShutterTypeTable();

inline const ::flatbuffers::TypeTable *Telem_stdcam_fbTypeTable();

struct ROI FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ROIBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ROITypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_XCEN = 4,
    VT_YCEN = 6,
    VT_W = 8,
    VT_H = 10,
    VT_XBIN = 12,
    VT_YBIN = 14
  };
  float xcen() const {
    return GetField<float>(VT_XCEN, 0.0f);
  }
  float ycen() const {
    return GetField<float>(VT_YCEN, 0.0f);
  }
  int32_t w() const {
    return GetField<int32_t>(VT_W, 0);
  }
  int32_t h() const {
    return GetField<int32_t>(VT_H, 0);
  }
  int32_t xbin() const {
    return GetField<int32_t>(VT_XBIN, 0);
  }
  int32_t ybin() const {
    return GetField<int32_t>(VT_YBIN, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_XCEN, 4) &&
           VerifyField<float>(verifier, VT_YCEN, 4) &&
           VerifyField<int32_t>(verifier, VT_W, 4) &&
           VerifyField<int32_t>(verifier, VT_H, 4) &&
           VerifyField<int32_t>(verifier, VT_XBIN, 4) &&
           VerifyField<int32_t>(verifier, VT_YBIN, 4) &&
           verifier.EndTable();
  }
};

struct ROIBuilder {
  typedef ROI Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_xcen(float xcen) {
    fbb_.AddElement<float>(ROI::VT_XCEN, xcen, 0.0f);
  }
  void add_ycen(float ycen) {
    fbb_.AddElement<float>(ROI::VT_YCEN, ycen, 0.0f);
  }
  void add_w(int32_t w) {
    fbb_.AddElement<int32_t>(ROI::VT_W, w, 0);
  }
  void add_h(int32_t h) {
    fbb_.AddElement<int32_t>(ROI::VT_H, h, 0);
  }
  void add_xbin(int32_t xbin) {
    fbb_.AddElement<int32_t>(ROI::VT_XBIN, xbin, 0);
  }
  void add_ybin(int32_t ybin) {
    fbb_.AddElement<int32_t>(ROI::VT_YBIN, ybin, 0);
  }
  explicit ROIBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ROI> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ROI>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ROI> CreateROI(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float xcen = 0.0f,
    float ycen = 0.0f,
    int32_t w = 0,
    int32_t h = 0,
    int32_t xbin = 0,
    int32_t ybin = 0) {
  ROIBuilder builder_(_fbb);
  builder_.add_ybin(ybin);
  builder_.add_xbin(xbin);
  builder_.add_h(h);
  builder_.add_w(w);
  builder_.add_ycen(ycen);
  builder_.add_xcen(xcen);
  return builder_.Finish();
}

struct TempCtrl FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TempCtrlBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TempCtrlTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEMP = 4,
    VT_SETPT = 6,
    VT_STATUS = 8,
    VT_ONTARGET = 10,
    VT_STATUSSTR = 12
  };
  float temp() const {
    return GetField<float>(VT_TEMP, 0.0f);
  }
  float setpt() const {
    return GetField<float>(VT_SETPT, 0.0f);
  }
  bool status() const {
    return GetField<uint8_t>(VT_STATUS, 0) != 0;
  }
  bool ontarget() const {
    return GetField<uint8_t>(VT_ONTARGET, 0) != 0;
  }
  const ::flatbuffers::String *statusStr() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATUSSTR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_TEMP, 4) &&
           VerifyField<float>(verifier, VT_SETPT, 4) &&
           VerifyField<uint8_t>(verifier, VT_STATUS, 1) &&
           VerifyField<uint8_t>(verifier, VT_ONTARGET, 1) &&
           VerifyOffset(verifier, VT_STATUSSTR) &&
           verifier.VerifyString(statusStr()) &&
           verifier.EndTable();
  }
};

struct TempCtrlBuilder {
  typedef TempCtrl Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_temp(float temp) {
    fbb_.AddElement<float>(TempCtrl::VT_TEMP, temp, 0.0f);
  }
  void add_setpt(float setpt) {
    fbb_.AddElement<float>(TempCtrl::VT_SETPT, setpt, 0.0f);
  }
  void add_status(bool status) {
    fbb_.AddElement<uint8_t>(TempCtrl::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  void add_ontarget(bool ontarget) {
    fbb_.AddElement<uint8_t>(TempCtrl::VT_ONTARGET, static_cast<uint8_t>(ontarget), 0);
  }
  void add_statusStr(::flatbuffers::Offset<::flatbuffers::String> statusStr) {
    fbb_.AddOffset(TempCtrl::VT_STATUSSTR, statusStr);
  }
  explicit TempCtrlBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TempCtrl> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TempCtrl>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TempCtrl> CreateTempCtrl(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float temp = 0.0f,
    float setpt = 0.0f,
    bool status = false,
    bool ontarget = false,
    ::flatbuffers::Offset<::flatbuffers::String> statusStr = 0) {
  TempCtrlBuilder builder_(_fbb);
  builder_.add_statusStr(statusStr);
  builder_.add_setpt(setpt);
  builder_.add_temp(temp);
  builder_.add_ontarget(ontarget);
  builder_.add_status(status);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TempCtrl> CreateTempCtrlDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float temp = 0.0f,
    float setpt = 0.0f,
    bool status = false,
    bool ontarget = false,
    const char *statusStr = nullptr) {
  auto statusStr__ = statusStr ? _fbb.CreateString(statusStr) : 0;
  return MagAOX::logger::CreateTempCtrl(
      _fbb,
      temp,
      setpt,
      status,
      ontarget,
      statusStr__);
}

struct Shutter FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ShutterBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ShutterTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUSSTR = 4,
    VT_STATE = 6
  };
  const ::flatbuffers::String *statusStr() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATUSSTR);
  }
  int32_t state() const {
    return GetField<int32_t>(VT_STATE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STATUSSTR) &&
           verifier.VerifyString(statusStr()) &&
           VerifyField<int32_t>(verifier, VT_STATE, 4) &&
           verifier.EndTable();
  }
};

struct ShutterBuilder {
  typedef Shutter Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_statusStr(::flatbuffers::Offset<::flatbuffers::String> statusStr) {
    fbb_.AddOffset(Shutter::VT_STATUSSTR, statusStr);
  }
  void add_state(int32_t state) {
    fbb_.AddElement<int32_t>(Shutter::VT_STATE, state, 0);
  }
  explicit ShutterBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Shutter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Shutter>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Shutter> CreateShutter(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> statusStr = 0,
    int32_t state = 0) {
  ShutterBuilder builder_(_fbb);
  builder_.add_state(state);
  builder_.add_statusStr(statusStr);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Shutter> CreateShutterDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *statusStr = nullptr,
    int32_t state = 0) {
  auto statusStr__ = statusStr ? _fbb.CreateString(statusStr) : 0;
  return MagAOX::logger::CreateShutter(
      _fbb,
      statusStr__,
      state);
}

struct Telem_stdcam_fb FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Telem_stdcam_fbBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Telem_stdcam_fbTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4,
    VT_ROI = 6,
    VT_EXPTIME = 8,
    VT_FPS = 10,
    VT_EMGAIN = 12,
    VT_ADCSPEED = 14,
    VT_TEMPCTRL = 16,
    VT_SHUTTER = 18,
    VT_SYNCHRO = 20,
    VT_VSHIFT = 22,
    VT_CROPMODE = 24
  };
  const ::flatbuffers::String *mode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MODE);
  }
  const MagAOX::logger::ROI *roi() const {
    return GetPointer<const MagAOX::logger::ROI *>(VT_ROI);
  }
  float exptime() const {
    return GetField<float>(VT_EXPTIME, 0.0f);
  }
  float fps() const {
    return GetField<float>(VT_FPS, 0.0f);
  }
  float emGain() const {
    return GetField<float>(VT_EMGAIN, 0.0f);
  }
  float adcSpeed() const {
    return GetField<float>(VT_ADCSPEED, 0.0f);
  }
  const MagAOX::logger::TempCtrl *tempCtrl() const {
    return GetPointer<const MagAOX::logger::TempCtrl *>(VT_TEMPCTRL);
  }
  const MagAOX::logger::Shutter *shutter() const {
    return GetPointer<const MagAOX::logger::Shutter *>(VT_SHUTTER);
  }
  uint8_t synchro() const {
    return GetField<uint8_t>(VT_SYNCHRO, 0);
  }
  float vshift() const {
    return GetField<float>(VT_VSHIFT, 0.0f);
  }
  int8_t cropMode() const {
    return GetField<int8_t>(VT_CROPMODE, -1);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MODE) &&
           verifier.VerifyString(mode()) &&
           VerifyOffset(verifier, VT_ROI) &&
           verifier.VerifyTable(roi()) &&
           VerifyField<float>(verifier, VT_EXPTIME, 4) &&
           VerifyField<float>(verifier, VT_FPS, 4) &&
           VerifyField<float>(verifier, VT_EMGAIN, 4) &&
           VerifyField<float>(verifier, VT_ADCSPEED, 4) &&
           VerifyOffset(verifier, VT_TEMPCTRL) &&
           verifier.VerifyTable(tempCtrl()) &&
           VerifyOffset(verifier, VT_SHUTTER) &&
           verifier.VerifyTable(shutter()) &&
           VerifyField<uint8_t>(verifier, VT_SYNCHRO, 1) &&
           VerifyField<float>(verifier, VT_VSHIFT, 4) &&
           VerifyField<int8_t>(verifier, VT_CROPMODE, 1) &&
           verifier.EndTable();
  }
};

struct Telem_stdcam_fbBuilder {
  typedef Telem_stdcam_fb Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mode(::flatbuffers::Offset<::flatbuffers::String> mode) {
    fbb_.AddOffset(Telem_stdcam_fb::VT_MODE, mode);
  }
  void add_roi(::flatbuffers::Offset<MagAOX::logger::ROI> roi) {
    fbb_.AddOffset(Telem_stdcam_fb::VT_ROI, roi);
  }
  void add_exptime(float exptime) {
    fbb_.AddElement<float>(Telem_stdcam_fb::VT_EXPTIME, exptime, 0.0f);
  }
  void add_fps(float fps) {
    fbb_.AddElement<float>(Telem_stdcam_fb::VT_FPS, fps, 0.0f);
  }
  void add_emGain(float emGain) {
    fbb_.AddElement<float>(Telem_stdcam_fb::VT_EMGAIN, emGain, 0.0f);
  }
  void add_adcSpeed(float adcSpeed) {
    fbb_.AddElement<float>(Telem_stdcam_fb::VT_ADCSPEED, adcSpeed, 0.0f);
  }
  void add_tempCtrl(::flatbuffers::Offset<MagAOX::logger::TempCtrl> tempCtrl) {
    fbb_.AddOffset(Telem_stdcam_fb::VT_TEMPCTRL, tempCtrl);
  }
  void add_shutter(::flatbuffers::Offset<MagAOX::logger::Shutter> shutter) {
    fbb_.AddOffset(Telem_stdcam_fb::VT_SHUTTER, shutter);
  }
  void add_synchro(uint8_t synchro) {
    fbb_.AddElement<uint8_t>(Telem_stdcam_fb::VT_SYNCHRO, synchro, 0);
  }
  void add_vshift(float vshift) {
    fbb_.AddElement<float>(Telem_stdcam_fb::VT_VSHIFT, vshift, 0.0f);
  }
  void add_cropMode(int8_t cropMode) {
    fbb_.AddElement<int8_t>(Telem_stdcam_fb::VT_CROPMODE, cropMode, -1);
  }
  explicit Telem_stdcam_fbBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Telem_stdcam_fb> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Telem_stdcam_fb>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Telem_stdcam_fb> CreateTelem_stdcam_fb(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> mode = 0,
    ::flatbuffers::Offset<MagAOX::logger::ROI> roi = 0,
    float exptime = 0.0f,
    float fps = 0.0f,
    float emGain = 0.0f,
    float adcSpeed = 0.0f,
    ::flatbuffers::Offset<MagAOX::logger::TempCtrl> tempCtrl = 0,
    ::flatbuffers::Offset<MagAOX::logger::Shutter> shutter = 0,
    uint8_t synchro = 0,
    float vshift = 0.0f,
    int8_t cropMode = -1) {
  Telem_stdcam_fbBuilder builder_(_fbb);
  builder_.add_vshift(vshift);
  builder_.add_shutter(shutter);
  builder_.add_tempCtrl(tempCtrl);
  builder_.add_adcSpeed(adcSpeed);
  builder_.add_emGain(emGain);
  builder_.add_fps(fps);
  builder_.add_exptime(exptime);
  builder_.add_roi(roi);
  builder_.add_mode(mode);
  builder_.add_cropMode(cropMode);
  builder_.add_synchro(synchro);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Telem_stdcam_fb> CreateTelem_stdcam_fbDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *mode = nullptr,
    ::flatbuffers::Offset<MagAOX::logger::ROI> roi = 0,
    float exptime = 0.0f,
    float fps = 0.0f,
    float emGain = 0.0f,
    float adcSpeed = 0.0f,
    ::flatbuffers::Offset<MagAOX::logger::TempCtrl> tempCtrl = 0,
    ::flatbuffers::Offset<MagAOX::logger::Shutter> shutter = 0,
    uint8_t synchro = 0,
    float vshift = 0.0f,
    int8_t cropMode = -1) {
  auto mode__ = mode ? _fbb.CreateString(mode) : 0;
  return MagAOX::logger::CreateTelem_stdcam_fb(
      _fbb,
      mode__,
      roi,
      exptime,
      fps,
      emGain,
      adcSpeed,
      tempCtrl,
      shutter,
      synchro,
      vshift,
      cropMode);
}

inline const ::flatbuffers::TypeTable *ROITypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "xcen",
    "ycen",
    "w",
    "h",
    "xbin",
    "ybin"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 6, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TempCtrlTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "temp",
    "setpt",
    "status",
    "ontarget",
    "statusStr"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ShutterTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "statusStr",
    "state"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *Telem_stdcam_fbTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 2 },
    { ::flatbuffers::ET_UCHAR, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_CHAR, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    MagAOX::logger::ROITypeTable,
    MagAOX::logger::TempCtrlTypeTable,
    MagAOX::logger::ShutterTypeTable
  };
  static const char * const names[] = {
    "mode",
    "roi",
    "exptime",
    "fps",
    "emGain",
    "adcSpeed",
    "tempCtrl",
    "shutter",
    "synchro",
    "vshift",
    "cropMode"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 11, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const MagAOX::logger::Telem_stdcam_fb *GetTelem_stdcam_fb(const void *buf) {
  return ::flatbuffers::GetRoot<MagAOX::logger::Telem_stdcam_fb>(buf);
}

inline const MagAOX::logger::Telem_stdcam_fb *GetSizePrefixedTelem_stdcam_fb(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<MagAOX::logger::Telem_stdcam_fb>(buf);
}

inline bool VerifyTelem_stdcam_fbBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MagAOX::logger::Telem_stdcam_fb>(nullptr);
}

inline bool VerifySizePrefixedTelem_stdcam_fbBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<MagAOX::logger::Telem_stdcam_fb>(nullptr);
}

inline void FinishTelem_stdcam_fbBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MagAOX::logger::Telem_stdcam_fb> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedTelem_stdcam_fbBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MagAOX::logger::Telem_stdcam_fb> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace logger
}  // namespace MagAOX

#endif  // FLATBUFFERS_GENERATED_TELEMSTDCAM_MAGAOX_LOGGER_H_
